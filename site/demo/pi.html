<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MonteCarlo Pi - Popcorn Demo</title>
    <link rel="icon" href="../favicon.svg" type="image/svg+xml" sizes="any">
    <link rel="stylesheet" href="../assets/style.css">
  </head>
  <body>
    <h1>MonteCarlo Pi</h1>
    <p class="muted">乱数で円内点の比率から π を推定します。Elixir 側で並列試行します。</p>

    <div class="nav"></div>

    <section id="logs-pane">
      <h3>Logs</h3>
      <pre id="logs"></pre>
    </section>

    <section id="about-pane">
      <h3>About this demo</h3>
      <pre id="about-md">
## このデモで分かること

- **並行性（アクターモデル）**: 複数アクター（軽量プロセス）に試行を分割し、メッセージで結果を集約。共有メモリやロックが不要。
- **予測可能な統計特性**: 誤差は概ね 1/√N で減少。ログに 1σ/2σ と z 値を出し、結果の妥当性を即確認。
- **観測可能性**: `System.monotonic_time/1` で所要時間を正しく計測。推定値・誤差・時間が一望できる。
- **失敗に強い設計に拡張可能**: Supervisor と組み合わせれば、計算アクターの再起動や段階的リトライも容易。

## WASM × Elixir と他言語の対比（所感メモ）
- **Elixir (AtomVM/Popcorn)**: パフォーマンスは中位だが、アクター/メッセージ指向で並行処理の表現力・堅牢性・可観測性が高い。
- **JavaScript**: 単体でも速いことが多い。Web Workers で並列化は可能だが、メッセージ境界や障害復旧の足場は自作になりがち。
- **Rust/C/C++ (WASM)**: 数値計算は最速クラス。代わりに並行設計や復旧戦略はアプリ層で明示的に設計する必要。
- **Go (WASM)**: 中〜上の性能。GC/スケジューラの特性を理解すれば良好。WASM threads が使えると強い。
- **Python 等 (Pyodide)**: 実装容易だが遅め。試行数や手法の工夫が前提。

      </pre>
    </section>

    <script type="module">
      import { runDemo } from "../assets/demo.js";
      import { injectNav } from "../assets/nav.js";
      injectNav();
      await runDemo({
        base: "./wasm",
        filter: (line) => line.startsWith("[pi]"),
        transform: (line) => line.replace(/^\[pi\]\s?/, "")
      });
    </script>
  </body>
  </html>


